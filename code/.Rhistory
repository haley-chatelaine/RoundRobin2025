mds.group.colors <- lapply(mds, function(x) cbind(x, meta.data.new$group.color))
# plot mds
png("/Users/chatelaineha/Documents/Beecher_Collaboration/Writing/data_code/outputs/unsupervisedRF_clusters_WITHdupes.png", width = 8, height = 4, units = "in", res = 600)
par(mfrow = c(2, 4), mgp = c(1.5,0.5,0), mar = c(3,3,2,2))
mapply(function (x, y) plot(x, pch=16, xlab="Dim1", ylab="Dim2", col = meta.data.new$group.color, cex = 1, main=paste(y)), mds.group.colors, names(mds.group.colors))
# check how k-means clustering performs on 2D mds data from all labs
for(i in 1:length(mds)){
k.means.i <- kmeans(mds[[i]], centers = length(unique(meta.data$group)))
plot(mds.group.colors[[i]], pch=16, xlab="Dim1", ylab="Dim2", col = meta.data.new$group.color, cex = 2, main=paste(names(mds)[[i]]))
points(k.means.i$centers[,1], k.means.i$centers[,2], pch = 19)
}
# calculate silhouette scores based on a priori clusters (from meta-data) and plot
for(i in 1:length(mds)){
sil.i <- silhouette(as.numeric(meta.data$group), dist(mds[[i]]))
print(fviz_silhouette(sil.i))
}
#install.packages("NMF")
#install.packages("RColorBrewer")
#install.packages("ggplotify")
library(NMF)
library(RColorBrewer)
library(pheatmap)
library(factoextra)
library(ggplot2)
library(ggpubr)
library(grid)
library(gridExtra)
library(ggplotify)
load("/Users/chatelaineha/Documents/Beecher_Collaboration/Writing/data_code/data/clustering_input/imputed_data.RData")
#par(mfrow = c(2,4))
lapply(norm.impute, function(x) plot(density(apply(x, 2, as.numeric)), main = ""))
#par(mfrow = c(2, 4))
lapply(norm.impute, function(x) boxplot((apply(x, 2, as.numeric)), main = ""))
nmf_basis <- function(data, rank = 3, meta.data, meta.col = c("group", "concentration"), print.heatmap = TRUE, seed = NULL){
# data = list of data from all labs
# rank = rank for determining basis (3 for this study design because A, B, C groups)
# meta.data = meta data with sample info
# meta.col = column to use for coloring heatmap
# print.heat = logical saying whether to print out the heatmaps
if(!is.null(seed)){
set.seed(seed)
}
# subset data into labs and groups if plotting by sample concentration
groups <- unique(meta.data$group)
if(meta.col == "concentration"){
data.new <- list()
length(data.new) <- length(data) * length(groups)
names(data.new) <- apply(expand.grid(names(data), groups), 1, paste, collapse="_")
for(i in 1:length(data.new)){
for(j in 1:length(data)){
group.rows <- gsub("_.*", "", row.names(data[[j]]))
for(k in 1:length(groups)){
if(grepl(names(data)[[j]], names(data.new)[[i]]) == T &
groups[k] == gsub(".*_", "", names(data.new)[[i]])){
data.new[[i]] <- data[[j]][which(group.rows == groups[k]),]
}
}
}
}
data <- data.new
}
w <- list(length(data))
if(print.heatmap == T){
heats <- list(length(data))
for(i in 1:length(data)){
# calculate NMF
res <- nmf(data[[i]], rank)
# extract basis
w[[i]] <- res@fit@W
# plot heatmap of basis
## scale basis
scale.w <- w[[i]] / max(w[[i]])
colnames(scale.w) <- seq(1, ncol(scale.w), by = 1)
## set annotation row
if(meta.col == "group"){
rows <- data.frame("group" = gsub("_.*", "", row.names(scale.w)))
}
if(meta.col == "concentration"){
conc <- gsub("_r.*", "", row.names(scale.w))
conc <- gsub("*._", "", conc)
rows <- data.frame("concentration" = conc)
}
row.names(rows) <- row.names(scale.w)
## set annotation column
cols <- data.frame("basis" = seq(1, ncol(scale.w), by = 1))
row.names(cols) <- colnames(scale.w)
## set annotation colors
if(meta.col == "group"){
group.colors <- c("red","orange","brown","purple","gold","darkgreen", "blue")
names(group.colors) <- levels(meta.data$group)
basis.colors <- brewer.pal(n = ncol(scale.w), "Paired")
annotation_colors <- list(group = group.colors, basis = basis.colors)
}
if(meta.col == "concentration"){
conc.colors <- brewer.pal(length(unique(conc)), "Blues")
names(conc.colors) <- unique(conc)
basis.colors <- brewer.pal(n = ncol(scale.w), "Paired")
annotation_colors <- list(concentration = conc.colors, basis = basis.colors)
}
## plot
heats[[i]] <- as.ggplot(pheatmap(scale.w,
color = colorRampPalette(brewer.pal(n = 9, name = "Oranges"))(100),
annotation_row = rows,
annotation_col = cols,
annotation_colors = annotation_colors,
annotation_legend = F,
main = names(data)[[i]]))
}
ggarrange(plotlist = heats, ncol = 4, nrow = 2, common.legend = T)
}else{
for(i in 1:length(data)){
# calculate NMF
res <- nmf(data[[i]], rank)
# extract basis
w[[i]] <- res@fit@W
}
}
# Calculate clustering performance
cluster.cor <- data.frame(matrix(nrow = length(w), ncol = 1))
row.names(cluster.cor) <- names(data)
colnames(cluster.cor) <- "correlation"
for(i in 1:length(w)){
w.hcut <- hcut(w[[i]], 7)
sample.classes <- data.frame("cluster" = w.hcut$cluster, "group" = meta.data$group)
cluster.cor.test <- cor.test(as.numeric(as.factor(meta.data$group)), w.hcut$cluster, method = "pearson")
cluster.cor[i,c("correlation")] <- cluster.cor.test$estimate
}
names(w) <- names(data)
return(list("w" = w, "correlation" = cluster.cor))
}
w <- nmf_basis(norm.impute, 3, meta.data, "group", print.heatmap = T, seed = 3)
nmf_basis(norm.impute, 3, meta.data, "group", print.heatmap = T, seed = 3)
ggsave("/Users/chatelaineha/Documents/Beecher_Collaboration/Writing/data_code/outputs/NMF_heatmap_WITH_dupes.png", width = 24, height = 16, dpi = 600)
nmf_cluster <- function(w, meta.data){
# w = basis from nmf_basis()
# meta.data = dataframe with sample groups
# set group colors
group.colors <- c("red","orange","brown","purple","gold","darkgreen", "blue")
names(group.colors) <- levels(meta.data$group)
group.colors.df <- data.frame(group = names(group.colors), group.color = group.colors)
clusterplot <- list(length(w))
for(i in 1:length(w)){
w.hcut <- hcut(w[[i]], 7)
sample.classes <- data.frame("cluster" = w.hcut$cluster, "group" = meta.data$group)
clusterplot[[i]] <- ggplot(sample.classes, aes(x = group, y = cluster, color = group)) +
geom_point(position = position_jitter(w = 0.25, h = 0), size = 2) +
scale_color_manual(values = group.colors) +
theme_classic() +
scale_y_continuous(breaks = seq(min(sample.classes$cluster), max(sample.classes$cluster), by = 1)) +
ggtitle(names(w)[[i]]) +
ylab("Basis Cluster") +
xlab("Sample Group")
}
ggarrange(plotlist = clusterplot, ncol = 4, nrow = 2, common.legend = T)
}
nmf_cluster(w$w, meta.data)
ggsave("/Users/chatelaineha/Documents/Beecher_Collaboration/Writing/data_code/outputs/NMF_cluster_correlations_WITH_dupes.png", width = 12, height = 8, dpi = 600)
# Function to extract features and relative contribution to each rank (as a fraction), and assign labels to ranks
nmf_feats <- function(data, rank = 3, meta.data, meta.col = c("group", "concentration")){
# data = list of data from all labs
# rank = rank for determining basis (3 for this study design because A, B, C groups)
# meta.data = meta data with sample info
# meta.col = column to use for coloring heatmap
set.seed(3)
# subset data into labs and groups if plotting by sample concentration
groups <- unique(meta.data$group)
if(meta.col == "concentration"){
data.new <- list()
length(data.new) <- length(data) * length(groups)
names(data.new) <- apply(expand.grid(names(data), groups), 1, paste, collapse="_")
for(i in 1:length(data.new)){
for(j in 1:length(data)){
group.rows <- gsub("_.*", "", row.names(data[[j]]))
for(k in 1:length(groups)){
if(grepl(names(data)[[j]], names(data.new)[[i]]) == T &
groups[k] == gsub(".*_", "", names(data.new)[[i]])){
data.new[[i]] <- data[[j]][which(group.rows == groups[k]),]
}
}
}
}
data <- data.new
}
# extract coefficients and basis
h <- list(length(data))
w <- list(length(data))
for(i in 1:length(data)){
# calculate NMF
res <- nmf(data[[i]], rank)
# extract coefficients
h[[i]] <- res@fit@H
# extract basis
w[[i]] <- res@fit@W
}
names(h) <- names(data)
names(w) <- names(data)
# determine labels for ranks
rank.labels <- list(length(w))
for(i in 1:length(w)){
## subset data to only include a, b, and c groups and calculate sums across ranks for each group
groups <- gsub("_.*", "", row.names(w[[i]]))
a.sum <- colSums(w[[i]][which(groups == "a"),])
b.sum <- colSums(w[[i]][which(groups == "b"),])
c.sum <- colSums(w[[i]][which(groups == "c"),])
# assign labels to the ranks
a.rank <- which(a.sum == max(a.sum))
b.rank <- which(b.sum == max(b.sum))
c.rank <- which(c.sum == max(c.sum))
rank.labels[[i]] <- c("a" = a.rank, "b" = b.rank, "c" = c.rank)
}
# convert coefficients to percent contribution across ranks
h.perc <- h
for(i in 1:length(h.perc)){
h.totals <- colSums(h.perc[[i]])
h.perc[[i]] <- sweep(h.perc[[i]], 2, h.totals, FUN = "/")
rows <- names(rank.labels[[i]][order(rank.labels[[i]])])
row.names(h.perc[[i]]) <- rows
}
names(h.perc) <- names(h)
return(h.perc)
}
h <- nmf_feats(norm.impute, rank = 3, meta.data, meta.col = "group")
save(h, comp.found.na.filter, file = "/Users/chatelaineha/Documents/Beecher_Collaboration/Writing/data_code/data/biomarker_input/NMF_features_WITH_dupes.RData")
# set number of iterations
x <- 100
# prep results
iteration.cor <- data.frame(matrix(nrow = length(norm.impute), ncol = x))
row.names(iteration.cor) <- names(norm.impute)
colnames(iteration.cor) <- paste0("model_", seq(1:x))
# run iterations
for(i in 1:x){
print(i)
model <- nmf_basis(norm.impute, rank = 3, meta.data, "group", print.heatmap = F)
iteration.cor[,i] <- model$correlation
}
# calculate average correlation across all iterations
iteration.cor$std.dev <- apply(iteration.cor,1, sd)
iteration.cor$average <- rowMeans(iteration.cor)
iteration.cor$average
iteration.cor$std.dev
data.8 <- norm.impute$Lab8
# Based on features that contribute a lot to each rank
all.means <- colMeans(data.8)
mean.8 <- c()
for(i in 1:ncol(data.8)){
if(colnames(data.8)[i] %in% high.8){
mean.8[i] <- colMeans(data.8)[i]
}else{next}
}
knitr::opts_chunk$set(echo = TRUE)
load("/Users/chatelaineha/Documents/Beecher_Collaboration/Writing/data_code/data/biomarker_input/ANOVA_features_WITH_duplicates.RData")
load("/Users/chatelaineha/Documents/Beecher_Collaboration/Writing/data_code/data/biomarker_input/PCA_features_WITHduplicates.RData")
load("/Users/chatelaineha/Documents/Beecher_Collaboration/Writing/data_code/data/biomarker_input/NMF_features_WITH_dupes.RData")
packages <- c("tidyverse", "dplyr", "ggplot2", "ggpattern", "plotly",
"RColorBrewer", "ggsci", "ggpubr", "pheatmap", "grafify",
"openxlsx", "data.table", "grafify", "factoextra", "htmltools", "colorspace")
installed_packages <- packages %in% rownames(installed.packages())
if (any(installed_packages == FALSE)) {
install.packages(packages[!installed_packages])
}
invisible(lapply(packages, library, character.only = TRUE))
anova.feats <- list(length(anova.results))
anova.feats <- lapply(anova.results, function(x) which(x < 0.05))
anova.feats <- lapply(anova.feats, function(x) names(x))
pca.feats <- lapply(norm.group.load, abs)
pca.filter <- function(lab.feats, cutoff){
# lab.feats = pca features from one lab
# cutoff = percentile cutoff
results <- apply(lab.feats, 2, function(x) which(x > quantile(x, cutoff)))
results <- apply(results, 2, function(x) row.names(lab.feats)[x])
return(results)
}
pca.feats <- lapply(pca.feats, function(x) pca.filter(x, 0.9))
pca.feats <- lapply(pca.feats, function(x) unique(c(x[,1], x[,2], x[,3])) )
nmf_feat_imp <- function(h, imp.cutoff = 0.67){
# h = matrix of feature coefficients expressed as a fraction of total contribution to each rank
# imp.cutoff = value for feature importance within each rank
# determine features with percent coefficient values above cutoff for each rank
h.feats <- list(length(h))
for(i in 1:length(h)){
a.feats <- colnames(h[[i]])[which(h[[i]][c("a"),] > imp.cutoff)]
b.feats <- colnames(h[[i]])[which(h[[i]][c("b"),] > imp.cutoff)]
c.feats <- colnames(h[[i]])[which(h[[i]][c("c"),] > imp.cutoff)]
h.feats[[i]] <- list("a" = a.feats, "b" = b.feats, "c" = c.feats)
}
names(h.feats) <- names(h)
return(h.feats)
}
nmf.feats <- nmf_feat_imp(h, 0.67)
all.feats <- c(unlist(anova.feats), unlist(pca.feats), unlist(nmf.feats))
all.feats <- gsub("_.*", "", all.feats)
results <- list()
for(i in 1:8){ # for all labs
print(i)
results[[i]] <- data.frame(matrix(ncol = 6))
colnames(results[[i]]) <- c("Name", "lab", "MF", "ANOVA", "PCA", "NMF")
for(j in 1:length(all.feats)){ # for all features that are significant anywhere
#print(j)
# if in all
if(all.feats[j] %in% anova.feats[[i]] &
all.feats[j] %in% pca.feats[[i]] &
all.feats[j] %in% unlist(nmf.feats[[i]])){
results[[i]] <- rbind(results[[i]], c("Name" = all.feats[j],
"lab" = names(anova.feats)[[i]],
"MF" = unique(comp.found.na.filter[[i]]$MF[
which(comp.found.na.filter[[i]]$Name == all.feats[j])]),
"ANOVA" = 1,
"PCA" = 1,
"NMF" = 1))
}
# if in ANOVA and PCA
else if(all.feats[j] %in% anova.feats[[i]] &
all.feats[j] %in% pca.feats[[i]] &
all.feats[j] %in% unlist(nmf.feats[[i]]) == F){
results[[i]] <- rbind(results[[i]], c("Name" = all.feats[j],
"lab" = names(anova.feats)[[i]],
"MF" = unique(comp.found.na.filter[[i]]$MF[
which(comp.found.na.filter[[i]]$Name == all.feats[j])]),
"ANOVA" = 1,
"PCA" = 1,
"NMF" = 0))
}
# if in ANOVA and NMF
else if(all.feats[j] %in% anova.feats[[i]] &
all.feats[j] %in% pca.feats[[i]] == F &
all.feats[j] %in% unlist(nmf.feats[[i]])){
results[[i]] <- rbind(results[[i]], c("Name" = all.feats[j],
"lab" = names(anova.feats)[[i]],
"MF" = unique(comp.found.na.filter[[i]]$MF[
which(comp.found.na.filter[[i]]$Name == all.feats[j])]),
"ANOVA" = 1,
"PCA" = 0,
"NMF" = 1))
}
# if in PCA and NMF
else if(all.feats[j] %in% anova.feats[[i]] == F &
all.feats[j] %in% pca.feats[[i]] &
all.feats[j] %in% unlist(nmf.feats[[i]])){
results[[i]] <- rbind(results[[i]], c("Name" = all.feats[j],
"lab" = names(anova.feats)[[i]],
"MF" = unique(comp.found.na.filter[[i]]$MF[
which(comp.found.na.filter[[i]]$Name == all.feats[j])]),
"ANOVA" = 0,
"PCA" = 1,
"NMF" = 1))
}
# if in only ANOVA
else if(all.feats[j] %in% anova.feats[[i]] &
all.feats[j] %in% pca.feats[[i]] == F &
all.feats[j] %in% unlist(nmf.feats[[i]]) == F){
results[[i]] <- rbind(results[[i]], c("Name" = all.feats[j],
"lab" = names(anova.feats)[[i]],
"MF" = unique(comp.found.na.filter[[i]]$MF[
which(comp.found.na.filter[[i]]$Name == all.feats[j])]),
"ANOVA" = 1,
"PCA" = 0,
"NMF" = 0))
}
# if in only PCA
else if(all.feats[j] %in% anova.feats[[i]] == F &
all.feats[j] %in% pca.feats[[i]] &
all.feats[j] %in% unlist(nmf.feats[[i]]) == F){
results[[i]] <- rbind(results[[i]], c("Name" = all.feats[j],
"lab" = names(anova.feats)[[i]],
"MF" = unique(comp.found.na.filter[[i]]$MF[
which(comp.found.na.filter[[i]]$Name == all.feats[j])]),
"ANOVA" = 0,
"PCA" = 1,
"NMF" = 0))
}
# if in only NMF
else if(all.feats[j] %in% anova.feats[[i]] == F &
all.feats[j] %in% pca.feats[[i]] == F &
all.feats[j] %in% unlist(nmf.feats[[i]])){
results[[i]] <- rbind(results[[i]], c("Name" = all.feats[j],
"lab" = names(anova.feats)[[i]],
"MF" = unique(comp.found.na.filter[[i]]$MF[
which(comp.found.na.filter[[i]]$Name == all.feats[j])]),
"ANOVA" = 0,
"PCA" = 0,
"NMF" = 1))
}
}
results[[i]] <- results[[i]][-which(rowSums(is.na(results[[i]])) == ncol(results[[i]])),]
}
results.df <- data.frame()
for(k in 1:length(results)){
results.df <- rbind(results.df, results[[k]])
}
# add number of analyses where the metabolite was important
sig.numbers <- apply(subset(results.df, select = c("ANOVA", "PCA", "NMF")), 2, as.numeric)
results.df$total.sig <- apply(sig.numbers, 1, sum)
# add number of labs where the MF was important in at least one analysis
mf <- unique(results.df$MF)
results.df$total.lab <- NA
for(i in 1:length(mf)){
subset.data <- results.df[which(results.df$MF == mf[i]),]
n.labs <- length(unique(subset.data$lab))
for(j in 1:nrow(results.df)){
if(results.df$MF[j] == mf[i]){
results.df$total.lab[j] <- n.labs
}
}
}
#write.csv(results.df, file = "/Users/chatelaineha/Documents/Beecher_Collaboration/Writing/data_code/data/biomarker_input/important_features_WITH_duplicates.csv", row.names = F)
n.sig.labs <- data.frame(matrix(nrow = length(unique(results.df$total.lab)), ncol = 3))
colnames(n.sig.labs) <- c("Number of Labs", "Number of Metabs")
for(i in 1:nrow(n.sig.labs)){
n.sig.labs$`Number of Labs`[i] <- paste0("Significant in ", i, " labs")
n.sig.labs$`Number of Metabs`[i] <- length(unique(results.df$MF[which(results.df$total.lab == i)]))
}
n.sig.analyses <- data.frame(matrix(nrow = length(unique(results.df$total.sig)), ncol = 3))
colnames(n.sig.analyses) <- c("Number of analyses", "Number of Metabs")
for(i in 1:nrow(n.sig.analyses)){
n.sig.analyses$`Number of analyses`[i] <- paste0("Significant in ", i, " analyses")
n.sig.analyses$`Number of Metabs`[i] <- length(unique(results.df$MF[which(results.df$total.sig == i)]))
}
load("/Users/chatelaineha/Documents/Beecher_Collaboration/Writing/data_code/data/duplicate_input/imputed_data.RData")
metabs.8 <- unique(results.df$MF[which(results.df$total.lab == 8)])
metab.boxplot <- function(norm.impute, metab){
# norm.impute = input data for boxplots
# metab = index of metabolite to plot from list (like metabs.8)
png(paste0("/Users/chatelaineha/Documents/Beecher_Collaboration/Writing/data_code/outputs/biomarker_boxplots_", metab, ".png"), width = 1600, height = 400)
par(mfrow = c(1, 8))
for(lab in 1:length(norm.impute)){
# Extract abundance data
metab.data <- norm.impute[[lab]][which(comp.found.na.filter[[lab]]$MF == metab)]
# Average data if multiple features for the MF
metab.avg <- rowMeans(metab.data, na.rm = T)
# Report number of features averaged
n.feats <- ncol(metab.data)
# Prepare for boxplots
box.data <- data.frame("avg.abund" = metab.avg, "sample.group" = gsub("_.*", "", row.names(metab.data)))
box.data$sample.group <- factor(box.data$sample.group, levels = c("a", "b", "c", "ab", "ac", "bc", "abc"))
box.data <- box.data[order(box.data$sample.group),]
# Make boxplots
## set group colors with gradients within groups
group.colors <- c("red","gold","blue","orange","purple","darkgreen","brown")
names(group.colors) <- levels(box.data$sample.group)
boxplot(box.data$avg.abund ~ box.data$sample.group,
col = group.colors,
main = paste(names(norm.impute)[[lab]], "-", metab, "-", n.feats, "features"),
xlab = "",
ylab = "",
xaxt = "n",
yaxt = "n",
cex.axis = 0.8)
axis(1, at = 1:7, label = c("a", "b", "c", "ab", "ac", "bc", "abc"), tck = -0.05)
axis(2, at = 1:5, label = seq(min(box.data$avg.abund), max(box.data$avg.abund), length.out = 5))
}
dev.off()
}
lapply(metabs.8, function(x) metab.boxplot(norm.impute, x))
load("/Users/chatelaineha/Documents/Beecher_Collaboration/Writing/data_code/data/duplicate_input/imputed_data.RData")
metabs.8 <- unique(results.df$MF[which(results.df$total.lab == 8)])
# Subset and prep abundance data
subset.metabs <- function(data.list, metab.list, lab, comp.meta, scale.metabs = F){
lab.comp <- comp.meta[[lab]]
lab.data <- data.list[[lab]]
colnames(lab.data) <- row.names(lab.comp)
subset.data <- lab.data[,which(lab.comp$MF %in% metab.list)]
if(scale.metabs == T){
subset.data <- scale(subset.data, scale = T)
}
subset.comp <- subset(lab.comp[which(lab.comp$MF %in% metab.list),],
select = c(Name, MF))
return(list(data = subset.data, meta = subset.comp))
}
lab.subset.data <- lapply(c("Lab1", "Lab2", "Lab3", "Lab4", "Lab5", "Lab6", "Lab7", "Lab8"),
function(x) subset.metabs(norm.impute, metabs.8, x, comp.found.na.filter, scale.metabs = T))
names(lab.subset.data) <- names(norm.impute)
# heatmap function
subset.heatmap <- function(lab.subset.data, lab, meta.data){
heat.data <- lab.subset.data[[lab]]
heat.data$meta <- heat.data$meta[order(heat.data$meta$MF),]
heat.data$data <- heat.data$data[,order(heat.data$meta$MF)]
annotations <- data.frame(MF = heat.data$meta$MF)
rownames(annotations) <- colnames(heat.data$data)
ann_colors <- list(MF = c(C11H12N2O2 = "#FF8080",
C11H20N2O3 = "#FFC266",
C16H29N3O4 = "#9999ff",
C4H7NO4 = "#79d279",
C8H16N2O3 = "#d9b3ff",
C8H20NO6P = "#dfbf9f",
C10H18N2O5 = "#c5c4c2"),
group = c(a = "red",
ab = "orange",
abc = "brown",
ac = "purple",
b = "gold",
bc = "forestgreen",
c = "blue"))
meta.data$group <- factor(meta.data$group, levels = c("a", "b", "c", "ab", "ac", "bc", "abc"))
heat.data$data <- heat.data$data[order(meta.data$group),]
meta.data <- meta.data[order(meta.data$group),]
heat <- as.ggplot(pheatmap(t(heat.data$data),
show_colnames = F,
show_rownames = F,
cluster_rows = F,
cluster_cols = F,
annotation_row = annotations,
annotation_col = subset(meta.data, select = c(group)),
annotation_colors = ann_colors,
main = lab,
legend = F,
annotation_legend = F,
fontsize = 5))
return(heat)
}
# heatmap
heatmaps <- lapply(c("Lab1", "Lab2", "Lab3", "Lab4", "Lab5", "Lab6", "Lab7", "Lab8"),
function(x) subset.heatmap(lab.subset.data, x, meta.data))
